#!/usr/bin/python
# Author: Thomas Beeney and Max Baldock
# Version: 1.1
# HTTP-GET Tool for removing false positives when auditing plaintext HTTP services

import requests
import sys
import argparse
import os
from libnmap.parser import NmapParser
import urllib3
import io
import contextlib

urllib3.disable_warnings()

COLOURS = {
    "blue": "\033[1;34m",
    "green": "\033[1;32m",
    "red": "\033[1;31m",
    "yellow": "\033[1;33m",
    "reset": "\033[0m"
}

SYMBOLS = {
    "plus": f"{COLOURS['blue']}[{COLOURS['reset']}{COLOURS['green']}+{COLOURS['reset']}{COLOURS['blue']}]",
    "minus": f"{COLOURS['blue']}[{COLOURS['reset']}{COLOURS['red']}-{COLOURS['reset']}{COLOURS['blue']}]",
    "cross": f"{COLOURS['blue']}[{COLOURS['reset']}{COLOURS['red']}x{COLOURS['reset']}{COLOURS['blue']}]",
    "star": f"{COLOURS['green']}[*]{COLOURS['reset']}{COLOURS['green']}",
    "warn": f"{COLOURS['blue']}[{COLOURS['reset']}{COLOURS['yellow']}!{COLOURS['reset']}{COLOURS['blue']}]",
    "end": f"{COLOURS['reset']}"
}


def banner():
    banner_text = r"""
  _   _   _                     _
 | |_| |_| |_ _ __ ___ __ _ ___| |_
 | ' \  _|  _| '_ \___/ _` / -_)  _|
 |_||_\__|\__| .__/   \__, \___|\__|
             |_|      |___/
    @BeeSec
    Helping you Bee Secure - https://github.com/BeeSec-UK/

usage: http_get_improved.py -i <input file> | -x <xml file> | -o <output_dir>
"""
    print(COLOURS["blue"] + banner_text + SYMBOLS["end"])


def parse_arguments() -> argparse.Namespace:
    parser = argparse.ArgumentParser(description="HTTP-GET Tool for scanning HTTP services")
    parser.add_argument("-i", "--ifile", help="Input file containing <host>:<port> entries.")
    parser.add_argument("-x", "--xfile", help="XML file generated by Nmap or Nmap merger.")
    parser.add_argument("-o", "--output", required=False, help="Directory for all output files.")
    return parser.parse_args()


def validate_file(file_path: str) -> bool:
    """Check if the file exists and is readable."""
    return os.path.isfile(file_path) and os.access(file_path, os.R_OK)


def initialize_output_files(output_dir: str) -> dict:
    """Create output files and return their file handles."""
    os.makedirs(output_dir, exist_ok=True)
    output_files = {
        "plaintext": open(os.path.join(output_dir, "http-get-plaintext.txt"), "w+"),
        "redirect": open(os.path.join(output_dir, "http-get-redirecting.txt"), "w+"),
        "errorlog": open(os.path.join(output_dir, "http-get-errorlog.txt"), "w+"),
        "warnings": open(os.path.join(output_dir, "http-get-warnings.txt"), "w+"),
        "log": open(os.path.join(output_dir, "http-get-log.csv"), "w+")
    }
    return output_files


def close_output_files(files: dict):
    """Close all output files."""
    for file in files.values():
        file.close()


def main():
    args = parse_arguments()

    if args.xfile:
        if not validate_file(args.xfile):
            print(SYMBOLS["cross"] + f" Error: Invalid XML file '{args.xfile}'." + SYMBOLS["end"])
            sys.exit(1)
        xml_file_scanner(args.xfile, args)
    elif args.ifile:
        if not validate_file(args.ifile):
            print(SYMBOLS["cross"] + f" Error: Invalid input file '{args.ifile}'." + SYMBOLS["end"])
            sys.exit(1)
        txt_file_scanner(args.ifile, args)
    else:
        print(SYMBOLS[
                  "cross"] + " Error: Either the -i or -x flag is required. Usage: python http_get_improved.py -i <input file> | -x <xml file>" +
              SYMBOLS["end"])
        sys.exit(2)


def xml_file_scanner(xml_file: str, args):
    report = NmapParser.parse_fromfile(xml_file)
    output_dir = args.output or input("Enter the directory to save the output files: ")
    output_files = initialize_output_files(output_dir)
    analyze_report(report, output_files)
    close_output_files(output_files)


def txt_file_scanner(target_file: str, args):
    output_dir = args.output or input("Enter the directory to save the output files: ")
    output_files = initialize_output_files(output_dir)

    with open(target_file, 'r') as file:
        for line in file:
            host, port = line.strip().split(':')
            analyze_service(host, port, output_files)

    print(SYMBOLS["plus"] + " Finished Testing all hosts! exiting.." + SYMBOLS["end"])
    close_output_files(output_files)


def analyze_report(report, output_files):
    total_services = 0

    for host in report.hosts:
        for service in host.services:
            if "http" in service.service.lower():
                total_services += 1
                analyze_service(host.address, service.port, output_files)

    if total_services == 0:
        print(SYMBOLS["plus"] + " No services found" + SYMBOLS["end"])

    print(SYMBOLS["plus"] + " Finished Testing all hosts! exiting.." + SYMBOLS["end"])


def analyze_service(host: str, port: str, output_files: dict):
    try:
        url = f"http://{host}:{port}"
        response = requests.get(url, allow_redirects=False, timeout=5)
        print(SYMBOLS["star"] + f' Testing host: {host} on port: {port}')
        print(SYMBOLS["plus"] + f' Webserver returned a {response.status_code} status code')

        if response.status_code == 200:
            print(SYMBOLS["cross"] + ' Web Server is plaintext' + SYMBOLS["end"])
            output_files["plaintext"].write(f"{host}:{port}\n")
            output_files["log"].write(f"{host}:{port}, {response.status_code}, n\n")
        elif response.status_code in [301, 302, 303, 307, 308]:
            handle_redirect(response, host, port, output_files)
        else:
            log_warning(f' Web server responded with a {response.status_code} and did not specify a redirect', host,
                        port, output_files)

    except requests.exceptions.RequestException as e:
        handle_request_exception(host, port, e, output_files)


def handle_redirect(response, host: str, port: str, output_files: dict):
    if "Location" in response.headers:
        print(SYMBOLS["plus"] + f' Webserver redirects to: {response.headers["Location"]}' + SYMBOLS["end"])
        redirect_url = response.headers["Location"]

        if "https" in redirect_url:
            print(SYMBOLS["plus"] + f' Following redirect to {redirect_url} for HSTS validation.')
            analyze_https_redirect(host, port, redirect_url, response, output_files)
        else:
            print(SYMBOLS["plus"] + ' Redirect is plaintext' + SYMBOLS["end"])
            output_files["plaintext"].write(f"{host}:{port}\n")
            output_files["log"].write(f"{host}:{port}, {response.status_code}, y, {redirect_url}\n")
    else:
        log_warning(f' Web server responded with a {response.status_code} and did not specify a redirect', host, port,
                    output_files)


def analyze_https_redirect(host: str, port: str, redirect_url: str, original_response, output_files: dict):
    try:
        s = requests.get(redirect_url, allow_redirects=True, timeout=5, verify=False)
        hsts_header = s.headers.get('Strict-Transport-Security')

        if hsts_header:
            # header, value = hsts_header.split("=")
            header, value = hsts_header.split(",")[0].split("=")
            max_age = ''.join(char for char in value if char.isdigit())

            if int(max_age) >= 7776000:
                print(SYMBOLS["minus"] + ' Webserver is Redirecting to https and includes HSTS declaration' + SYMBOLS[
                    "end"])
                output_files["redirect"].write(f"{host}:{port}\n")
                output_files["log"].write(
                    f"{host}:{port}, {original_response.status_code}, y, {redirect_url}, {header}:{value}\n")
            else:
                log_warning(f' Webserver is Redirecting to https but HSTS max-age value is too low', host, port,
                            output_files)
                output_files["log"].write(
                    f"{host}:{port}, {original_response.status_code}, y, {redirect_url}, {header}:{value}\n")
        else:
            log_warning(f' Webserver utilises a redirect to HTTPS, but HSTS declaration is not present.', host, port,
                        output_files)

    except requests.exceptions.RequestException as e:
        handle_request_exception(host, port, e, output_files)


def log_warning(message: str, host: str, port: str, output_files: dict):
    print(SYMBOLS["warn"] + message + SYMBOLS["end"])
    output_files["warnings"].write(f'{message} {host}:{port}\n')
    output_files["log"].write(f"{host}:{port}, Warning\n")


def handle_request_exception(host: str, port: str, exception: Exception, output_files: dict):
    print(SYMBOLS["cross"] + f' Error occurred while testing {host}:{port}: {exception}' + SYMBOLS["end"])
    output_files["errorlog"].write(f'Error occurred while testing {host}:{port}: {exception}\n')
    output_files["log"].write(f"{host}:{port}, Error, n\n")


def get_terminal_output():
    """Capture the terminal output and return it as a string."""
    output = io.StringIO()
    with contextlib.redirect_stdout(output):
        main()
        banner()
    return output.getvalue()

if __name__ == "__main__":
    main()
    banner()
